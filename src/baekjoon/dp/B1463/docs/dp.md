# **1. 백트래킹 + 중복 탐색 제거(메모이제이션)**

DP를 처음 접할 때 가장 좋은 방법은 **백트래킹(재귀)**을 먼저 이해하고, 그 과정에서 발생하는 **중복 탐색을 제거하는 방식**으로 접근하는 것이다.

백트래킹 기반 재귀는 문제의 모든 경우를 시도하며 답을 찾는 방식이다.
하지만 이 과정에서는 동일한 부분 문제를 **여러 번 반복해서** 계산하는 비효율이 생긴다.

이 반복되는 연산을 해결하기 위한 기법이 바로 **메모이제이션**이다.
즉,

> *"재귀로 문제를 풀되, 이미 계산한 값은 저장해두고 다시 계산하지 않는다."*

이 방식이 바로 **Top-Down DP**다.

### ✔ 장점

* 문제 구조를 직관적으로 이해할 수 있다
* 구현 난이도가 낮아 DP 입문에 가장 적합하다

### ✔ 단점

* 재귀 호출이 깊어지면 스택 메모리 한계로 인해 **Stack Overflow** 위험이 있다
* 함수 호출 오버헤드로 인해 속도가 느릴 수 있다
* 난이도 높은 DP 문제는 이 방식만으로 해결하기 어렵다

즉, **DP 감각을 익히기 위한 시작점**으로는 매우 좋지만,
실전 고난도 문제는 다른 방식으로 접근해야 한다.

---

# **2. 점화식을 만들고 반복문으로 구현하기(Bottom-Up)**

동적 프로그래밍의 본질은 사실 **점화식(recurrence relation)**을 세우는 데 있다.

문제를 보고 다음과 같은 단계를 거친다:

1. `dp[i]`의 의미를 명확히 정의한다
2. `dp[i]`를 구하기 위해 필요한 이전 상태들(`dp[i-1]`, `dp[i-2]` 등)을 찾는다
3. 그 관계를 식으로 표현한다 → 점화식
4. 반복문으로 계산한다

이 과정이 바로 **Bottom-Up DP**다.

### ✔ 장점

* 매우 빠르다
* 스택 오버플로우 위험이 없다
* 복잡한 DP 문제 해결 가능

### ✔ 단점

* 처음에는 점화식이 떠오르지 않는다
* 수학적 사고와 상태 정의 능력이 필요하다

즉, 이 방식은 **실전에서 반드시 필요한 DP 방식**이지만,
처음부터 이 방법으로만 접근하면 매우 어렵다.

--- 

